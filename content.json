{"meta":{"title":"Yanko","subtitle":"","description":"","author":"木 直","url":"https://74hz.github.io","root":"/"},"pages":[{"title":"Category","date":"2024-09-07T06:52:23.923Z","updated":"2024-09-07T06:52:23.923Z","comments":true,"path":"categories/index.html","permalink":"https://74hz.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tag","date":"2024-09-07T06:52:23.924Z","updated":"2024-09-07T06:52:23.924Z","comments":true,"path":"tags/index.html","permalink":"https://74hz.github.io/tags/index.html","excerpt":"","text":""},{"title":"Links","date":"2025-10-16T07:43:32.374Z","updated":"2025-10-16T07:43:32.374Z","comments":true,"path":"friends/index.html","permalink":"https://74hz.github.io/friends/index.html","excerpt":"","text":""},{"title":"Search","date":"2024-09-07T06:52:23.924Z","updated":"2024-09-07T06:52:23.924Z","comments":true,"path":"search/index.html","permalink":"https://74hz.github.io/search/index.html","excerpt":"","text":""}],"posts":[{"title":"现代前端工程化中的SourceMap探析","slug":"现代前端工程化中的SourceMap探析","date":"2025-10-11T02:51:25.000Z","updated":"2025-10-13T02:41:06.173Z","comments":true,"path":"article/0967afaca117/","link":"","permalink":"https://74hz.github.io/article/0967afaca117/","excerpt":"","text":"一、引言想象这样一个场景：某天凌晨，你接到紧急通知，生产环境的页面出现了严重的 JavaScript 错误，用户无法正常使用。你打开浏览器的开发者工具，看到的错误是这样的： Uncaught TypeError: Cannot read property &#x27;map&#x27; of undefined at r.a (bundle.min.js:1:45231) at u (bundle.min.js:1:38492) at bundle.min.js:1:40157 代码已经被压缩成了一行，变量名都变成了单个字母，你完全不知道错误发生在哪个文件、哪个函数中。这时候，SourceMap 就能拯救你。 在现代前端开发中，生产环境的代码往往经历了多重转换： TypeScript&#x2F;JSX 编译成 JavaScript ES6+ 语法转换为 ES5 代码压缩和混淆 多个模块打包成一个文件 这些转换虽然提升了性能和兼容性，但也让调试变得异常困难。SourceMap 正是为了解决这个问题而生的——它建立了转换后代码与源代码之间的映射关系，让我们能够在压缩后的代码中定位到原始源代码的准确位置。 二、SourceMap 基础概念2.1 什么是 SourceMapSourceMap（源代码映射）是一个存储了源代码与转换后代码之间位置映射关系的 JSON 格式文件。它的文件扩展名通常是 .map，例如 bundle.js.map。 SourceMap 已经成为了正式的 ECMAScript 标准，详细规范可以参考 ECMA-426。 当浏览器加载了带有 SourceMap 的 JavaScript 文件时，开发者工具能够： 将压缩后的代码位置映射回原始源代码 显示原始的变量名和函数名 在原始源代码中设置断点 展示清晰的错误堆栈信息 2.2 为什么需要 SourceMap代码转换的必要性现代前端开发中，代码转换是不可避免的： 性能优化：压缩和混淆能减小文件体积，提升加载速度 兼容性：需要将新语法转换为旧版本浏览器支持的代码 开发效率：使用 TypeScript、JSX 等提高开发体验 模块化：将多个模块打包成少量文件，减少 HTTP 请求 调试的困境然而，这些转换带来了调试难题： // 原始代码function calculateUserScore(user) &#123; const baseScore = user.activities.map((activity) =&gt; activity.points).reduce((a, b) =&gt; a + b, 0); return baseScore * user.multiplier;&#125; // 压缩后function r(n) &#123; const t = n.activities.map((n) =&gt; n.points).reduce((n, t) =&gt; n + t, 0); return t * n.multiplier;&#125; 如果压缩后的代码出错，你根本无法快速定位问题所在。 2.3 SourceMap 的工作原理浏览器如何识别 SourceMap转换后的 JavaScript 文件末尾通常会包含一条特殊注释： //# sourceMappingURL=bundle.js.map 或者使用 Data URL 内联： //# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLC... 浏览器的开发者工具检测到这个注释后，会自动下载对应的 .map 文件，并在调试时使用映射信息。 映射过程当你在 DevTools 中查看错误堆栈或设置断点时： DevTools 读取压缩代码中的位置信息（行号、列号） 在 SourceMap 文件中查找对应的映射关系 定位到原始源代码的准确位置 显示原始的文件名、函数名和代码内容 三、SourceMap 文件格式深入解析3.1 .map 文件的基本结构一个典型的 SourceMap 文件是 JSON 格式，结构如下： &#123; &quot;version&quot;: 3, &quot;file&quot;: &quot;bundle.min.js&quot;, &quot;sourceRoot&quot;: &quot;&quot;, &quot;sources&quot;: [&quot;webpack://myapp/./src/index.js&quot;, &quot;webpack://myapp/./src/utils.js&quot;], &quot;sourcesContent&quot;: [ &quot;import &#123; helper &#125; from &#x27;./utils&#x27;;\\nconsole.log(helper());&quot;, &quot;export function helper() &#123;\\n return &#x27;Hello&#x27;;\\n&#125;&quot; ], &quot;names&quot;: [&quot;console&quot;, &quot;log&quot;, &quot;helper&quot;, &quot;result&quot;], &quot;mappings&quot;: &quot;AAAA,OAAOA,QAAQ,SAASC,CAAAA,GAAAA&quot;&#125; 3.2 核心字段详解 字段 类型 说明 version Number SourceMap 规范版本号，根据 ECMA-426 标准，该值已硬编码为固定值 3 file String 转换后的文件名 sourceRoot String 源文件根路径，可选 sources Array 原始源文件列表 sourcesContent Array 源文件内容（可选，用于内联） names Array 转换前的变量名和属性名列表 mappings String 核心：Base64 VLQ 编码的映射数据 3.3 mappings 字段原理mappings 字段是 SourceMap 的核心，使用 Base64 VLQ 编码来高效存储位置映射关系。 基本结构 分号 ; 分隔生成代码的每一行 逗号 , 分隔同一行内的多个映射点 每个映射点包含 1-5 个相对偏移值：生成列、源文件索引、源行、源列、变量名索引 编码特点VLQ (Variable Length Quantity) 编码使用 Base64 字符，每个字符存储 5 位数据，支持变长整数和相对偏移，大幅减少存储空间。 完整编码规范请参考ECMA-426或sourcemaps.info。 3.4 手动解析示例我们可以使用 source-map 库来解析 SourceMap： import &#123; SourceMapConsumer &#125; from &quot;source-map&quot;;async function parseSourceMap(mapContent) &#123; const consumer = await new SourceMapConsumer(mapContent); // 查询转换后代码 (1, 45231) 对应的源代码位置 const original = consumer.originalPositionFor(&#123; line: 1, column: 45231, &#125;); console.log(original); // &#123; // source: &#x27;webpack://myapp/./src/user.js&#x27;, // line: 23, // column: 15, // name: &#x27;calculateUserScore&#x27; // &#125; consumer.destroy();&#125; 四、构建工具中的 SourceMap 配置4.1 Vite 的 SourceMap 配置本文以 Vite 为主，其他主流构建工具的 SourceMap 配置方式类似。具体配置可参考各工具官方文档。 配置选项Vite 的 build.sourcemap 选项支持以下值： 配置值 说明 适用场景 false 不生成 SourceMap 生产环境，不需要调试 true 生成独立的 .map 文件，并添加引用注释 开发环境，或需要公开调试的生产环境 &#39;inline&#39; SourceMap 作为 Data URL 内联到文件中 特殊调试场景，不推荐生产使用 &#39;hidden&#39; 生成 .map 文件，但不添加引用注释 生产环境，配合错误监控平台使用 开发环境配置开发环境下，Vite 默认启用 SourceMap，无需额外配置。 SourceMap 的存储路径 Vite 在开发环境中会在不同位置生成 SourceMap： 1. 依赖预构建的 SourceMap Vite 会对 node_modules 中的依赖进行预构建优化（使用 esbuild），这些文件的 SourceMap 会实际写入磁盘： node_modules/.vite/deps/ ├── react.js ├── react.js.map # 预构建依赖的 SourceMap └── _metadata.json 2. 项目源码的 SourceMap 对于你的项目源码（src/ 目录下的文件），Vite 采用不同的策略： 直接提供源文件：通过 /@fs/ 虚拟路径直接访问磁盘上的源文件 即时转换：TypeScript、Vue、JSX 等在内存中即时转换 内联 SourceMap：转换后的代码通常使用内联的 Data URL 格式的 SourceMap 例如： // 转换后的代码末尾//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLC... 或者直接映射到原始文件： //# sourceMappingURL=/@fs/Users/yourname/project/src/components/App.vue 生产环境配置根据不同需求场景选择合适的配置： 场景 1：完全不需要调试 // vite.config.jsexport default defineConfig(&#123; build: &#123; sourcemap: false, // 不生成 SourceMap &#125;,&#125;); 场景 2：需要调试但不想暴露源码（推荐） // vite.config.jsexport default defineConfig(&#123; build: &#123; sourcemap: &quot;hidden&quot;, // 生成 .map 但不添加引用 &#125;,&#125;); 生成完整的 .map 文件，但不在打包文件中添加 //# sourceMappingURL 注释，可以手动上传到错误监控平台。 场景 3：使用错误监控平台（如 Sentry） // vite.config.jsimport &#123; defineConfig &#125; from &quot;vite&quot;;import &#123; sentryVitePlugin &#125; from &quot;@sentry/vite-plugin&quot;;export default defineConfig(&#123; build: &#123; sourcemap: true, // 生成 SourceMap &#125;, plugins: [ // Sentry 插件会自动上传 SourceMap sentryVitePlugin(&#123; org: &quot;your-org&quot;, project: &quot;your-project&quot;, authToken: process.env.SENTRY_AUTH_TOKEN, // 上传后删除本地 SourceMap sourcemaps: &#123; assets: &quot;./dist/**&quot;, filesToDeleteAfterUpload: &quot;./dist/**/*.map&quot;, &#125;, &#125;), ],&#125;); 场景 4：内联 SourceMap（不推荐生产环境） // vite.config.jsexport default defineConfig(&#123; build: &#123; sourcemap: &quot;inline&quot;, // SourceMap 内联到文件中 &#125;,&#125;); 会显著增加打包文件体积，一般仅用于特殊调试场景。 五、生产环境的 SourceMap 策略5.1 安全性考虑SourceMap 泄露的风险如果在生产环境中直接暴露 SourceMap 文件，可能导致： 源代码泄露：攻击者可以完整还原你的源代码 业务逻辑暴露：核心算法、API 接口等被获取 敏感信息泄露：注释中的 TODO、密钥、内部地址等 知识产权风险：商业代码被竞争对手获取 5.2 私有化方案方案 1：Hidden SourceMap + 错误监控工作流程： 构建时生成 SourceMap，但不在 bundle 中引用 将 SourceMap 上传到 Sentry 等平台 生产环境部署时删除 .map 文件 用户端错误上报到 Sentry，平台自动还原堆栈 方案 2：条件性返回 SourceMap通过服务器配置，只对特定条件返回 SourceMap： # Nginx 配置location ~* \\.map$ &#123; # 只允许内网 IP 访问 allow 10.0.0.0/8; allow 192.168.0.0/12; deny all;&#125; // Node.js 中间件示例app.use(&quot;/static/*.map&quot;, (req, res, next) =&gt; &#123; const allowedIPs = [&quot;192.168.1.1&quot;, &quot;10.0.0.1&quot;]; if (allowedIPs.includes(req.ip)) &#123; next(); &#125; else &#123; res.status(403).send(&quot;Forbidden&quot;); &#125;&#125;); 5.3 性能影响分析文件体积SourceMap 文件通常比原始 bundle 还大： bundle.js 250 KB (压缩后)bundle.js.map 800 KB (未压缩) 如果使用 inline，会将 map 内容嵌入到 bundle 中，导致文件体积暴增。 运行时性能重要：SourceMap 不会影响运行时性能！ .map 文件只在打开 DevTools 时才会加载 普通用户访问页面不会下载 SourceMap 即使下载，也不会执行任何代码 六、SourceMap 规范演进版本历史 V1（2009）：Google Closure Compiler 首次引入，格式冗余 V2：改进，但仍不够高效 V3（2011-2024）：2024 年被 ECMA 标准化为 ECMA-426 V3 的关键改进 Base64 VLQ 编码：相比 V2 减小约 50% 体积 相对位置：使用偏移量而非绝对值 sourcesContent：可选的内联源码 sourceRoot：统一的源文件根路径 ECMA-426 标准化（2024）2024 年，SourceMap V3 规范正式被 ECMA International 标准化为 ECMA-426，这标志着： 版本号固定：version 字段被硬编码为固定值 3，不再有版本演进 规范稳定：成为正式的 ECMA 标准，确保长期稳定性 广泛支持：所有主流浏览器和构建工具都遵循此标准 向后兼容：与之前的 V3 草案完全兼容 这意味着未来不会有 V4 或更高版本，任何新特性都将通过扩展字段的方式添加，而不会改变核心格式。 ECMA-426 中的原文：The source map format does not have version numbers anymore, and it is instead hard-coded to always be “3”. 扩展字段虽然版本号固定，但规范允许通过添加自定义字段来扩展功能： &#123; &quot;version&quot;: 3, &quot;file&quot;: &quot;bundle.js&quot;, &quot;sources&quot;: [&quot;input.js&quot;], &quot;mappings&quot;: &quot;AAAA&quot;, // 自定义扩展字段 &quot;x_google_linecount&quot;: 100, &quot;x_custom_metadata&quot;: &#123; &quot;buildTool&quot;: &quot;vite&quot;, &quot;timestamp&quot;: &quot;2024-10-11&quot; &#125;&#125; 推荐使用 x_ 前缀来标识自定义字段，避免与未来可能的标准字段冲突。 七、总结SourceMap 通过将转换&#x2F;压缩后的代码精准映射回源代码，显著提升了调试与故障定位效率；其核心是使用 Base64 VLQ 编码的 mappings 字段，且仅在打开 DevTools 时才会加载，不影响运行时性能。 在 Vite 场景下： 开发态默认提供可调试映射：依赖预构建的 map 落盘，项目源码多以内联&#x2F;虚拟路径形式提供，能够直接定位到 TS&#x2F;JSX&#x2F;Vue 源文件。 生产态按需选择 build.sourcemap：false&#x2F;true&#x2F;inline&#x2F;hidden。 安全与合规： 公开 SourceMap 可能导致源码与敏感信息泄露，应避免在生产对外暴露，谨慎包含 sourcesContent。 使用私有化上传、IP 白名单或网关鉴权，配合发布版本号与静态资源前缀确保符号化准确。 规范与演进： 2024 年标准化为 ECMA-426，version 固定为 3，生态稳定可靠；新能力通过扩展字段演进，向后兼容良好。 SourceMap 虽然看似只是一个技术细节，但它连接了开发体验与生产调试两个关键场景。掌握 SourceMap 的原理和最佳实践，能让你在代码出错时快速定位问题，在构建优化时做出明智选择，最终提升整个团队的开发效率。 参考资料 ECMA-426: ECMAScript Source Map Standard (2024) - SourceMap 官方 ECMA 标准 Source Map Specification - SourceMap 规范详细文档 MDN: Source Map (Glossary) - MDN 关于 SourceMap 的权威解释 Source Map Revision 3 Proposal - V3 版本原始提案文档 mozilla&#x2F;source-map - Mozilla 官方 SourceMap 解析库 Sentry SourceMap 文档 - Sentry 错误监控集成","categories":[{"name":"前端","slug":"前端","permalink":"https://74hz.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"SourceMap","slug":"SourceMap","permalink":"https://74hz.github.io/tags/SourceMap/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://74hz.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"调试","slug":"调试","permalink":"https://74hz.github.io/tags/%E8%B0%83%E8%AF%95/"}]},{"title":"Tauri MacOS应用构建指南：从打包、代码签名到公证实践","slug":"Tauri-MacOS应用构建指南：从打包、代码签名到公证实践","date":"2025-07-23T03:26:21.000Z","updated":"2025-07-23T06:33:43.661Z","comments":true,"path":"article/274a96aab328/","link":"","permalink":"https://74hz.github.io/article/274a96aab328/","excerpt":"","text":"写作背景在开始技术实践之前，先简单说明一下这篇文章的写作背景。目前网上关于Tauri构建macOS应用的完整指南相对较少，特别是涉及代码签名和公证的详细实践步骤。本文的主要目的有两个： 个人记录 - 作为自己在Tauri开发过程中的经验总结和技术备忘 社区贡献 - 希望能为同样遇到macOS构建问题的开发者提供一个完整的解决方案 为什么需要代码签名和公证？当我们开发完成一个Tauri应用并准备在macOS上分发时，经常会遇到用户反馈的两个核心问题，这些问题直接影响了应用的用户体验和可信度： 代码签名的必要性问题现象： 如果不进行代码签名，用户在安装或首次运行应用时会遇到以下错误提示： &quot;应用程序&quot; 已损坏，无法打开。您应该将它移到废纸篓。 产生原因： 这是因为macOS的Gatekeeper安全机制会阻止运行未经Apple认证的应用程序。从macOS 10.15 Catalina开始，Apple进一步加强了对未签名应用的限制，未签名的应用会被标记为”损坏”。 影响： 用户无法正常启动应用 降低用户对应用的信任度 可能导致用户直接放弃使用 增加技术支持的工作量 软件公证的必要性问题现象： 即使进行了代码签名，如果没有进行软件公证，用户仍可能在安装时看到警告： macOS无法验证此App不包含恶意软件。 产生原因： 从macOS 10.15开始，Apple要求所有在macOS上分发的软件都必须经过公证（Notarization）。公证是Apple的一项自动化服务，它会扫描你的软件是否包含恶意内容，并为通过检查的软件颁发票证。 影响： 用户需要额外的步骤才能安装应用 显示安全警告会让用户产生疑虑 可能被误认为是恶意软件 影响应用的专业形象 解决方案的价值通过正确的代码签名和公证流程，我们可以： 提升用户体验 - 用户可以无障碍地安装和运行应用 建立信任关系 - 显示开发者的专业性和对安全的重视 符合平台规范 - 遵循Apple的分发政策和最佳实践 减少支持成本 - 避免因安装问题产生的用户咨询 接下来，我们将详细介绍如何为Tauri应用实现完整的代码签名和公证流程。 Tauri 代码签名与公证所需环境变量在 macOS 上对 Tauri 应用进行签名和公证时，通常需要配置以下环境变量： 下文会详细介绍每个变量的获取方式和来源。 APPLE_SIGNING_IDENTITY：签名证书在钥匙串中的名称（签名标识）。 APPLE_CERTIFICATE：从钥匙串导出的 .p12 证书的 base64 字符串（适用于 CI 或没有本地证书时）。 APPLE_CERTIFICATE_PASSWORD：.p12 证书的密码。 APPLE_ID：你的 Apple 账号邮箱（用于公证）。 APPLE_PASSWORD：Apple 账号的 App 专用密码（用于公证）。 APPLE_TEAM_ID：你的 Apple 开发者团队 ID（用于公证）。 APPLE_API_ISSUER：App Store Connect API 的 Issuer ID（用于公证，可选）。 APPLE_API_KEY：App Store Connect API 的密钥 ID（用于公证，可选）。 APPLE_API_KEY_PATH：App Store Connect API 的私钥文件路径（用于公证，可选）。 APPLE_API_KEY_CONTENT：App Store Connect API 的私钥内容（base64，可选）。 说明： 证书相关变量（如 APPLE_SIGNING_IDENTITY、APPLE_CERTIFICATE、APPLE_CERTIFICATE_PASSWORD）用于应用签名。 Apple ID 相关变量（如 APPLE_ID、APPLE_PASSWORD、APPLE_TEAM_ID）或 App Store Connect API 相关变量（如 APPLE_API_ISSUER、APPLE_API_KEY、APPLE_API_KEY_PATH）用于应用公证。 你可以根据实际需求选择 Apple ID 方式或 API 密钥方式进行公证。 详细说明和配置方法可参考 Tauri 官方文档。 准备工作证书申请与导入流程1. 生成证书签名请求（CSR）在本地 Mac 上打开“钥匙串访问”，依次点击菜单栏 钥匙串访问 &gt; 证书助理 &gt; 从证书颁发机构请求证书...，填写你的开发者邮箱和常用名称，选择“保存到磁盘”，生成一个 .certSigningRequest 文件。 2. 登录 Apple Developer 网站申请证书 进入 Apple Developer Certificates 页面。 点击右上角 “+” 按钮，选择 Developer ID Application 类型。 上传刚才生成的 .certSigningRequest 文件，提交后即可下载到 .cer 证书文件。 如果需要签名安装包（.pkg），同理选择 Developer ID Installer 类型申请。其它证书类型请根据实际需求自行了解。 3. 导入证书到钥匙串双击下载的 .cer 文件，证书会自动导入到“登录”钥匙串。可以在“钥匙串访问”中搜索 Developer ID Application 或你的开发者名称，确认证书已导入。 证书导入钥匙串后，可以在“钥匙串访问”应用的“我的证书”标签下，找到你的证书条目，名称即为签名标识（如：Developer ID Application: 你的名字 (XXXXXXXXXX)）。你也可以在终端执行以下命令，列出所有可用的签名标识： security find-identity -v -p codesigning 输出结果中类似于 1) XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX &quot;Developer ID Application: 你的名字 (XXXXXXXXXX)&quot;，其中最前面的那串大写字母和数字就是证书的 SHA-1 指纹。 你可以将 APPLE_SIGNING_IDENTITY 设置为证书的完整名称（如： APPLE_SIGNING_IDENTITY=&quot;Developer ID Application: 你的名字 (XXXXXXXXXX)&quot; 但更推荐直接填写证书的 SHA-1 指纹（即上面命令输出行最前面的那串），例如： APPLE_SIGNING_IDENTITY=&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot; 这样最为精准，也能避免因证书名称变化导致的识别问题。 注意：如果你的钥匙串中存在多个同名证书（例如多个 Developer ID Application: 你的名字 (XXXXXXXXXX)），直接使用证书名称作为 APPLE_SIGNING_IDENTITY 可能会导致签名时匹配到错误的证书。此时，更推荐使用证书的 SHA-1 指纹，这样可以确保唯一且精准地指定所需证书，避免因重名导致的各种问题。 4. 导出证书为 p12步骤操作： 打开“钥匙串访问”应用，点击左侧“登录”类型，切换到“我的证书”标签。 找到你的证书条目，展开后右键点击证书，选择“导出”。 选择保存为 .p12 文件，并为导出的证书设置一个密码（建议妥善保存）。 在终端运行以下命令，将 .p12 文件转换为 base64 格式： openssl base64 -in /your path/certificate.p12 -out certificate.txt 打开 certificate.txt 文件，将内容设置为环境变量 APPLE_CERTIFICATE 的值。 将导出时设置的证书密码设置为环境变量 APPLE_CERTIFICATE_PASSWORD。 这样可以方便在自动化构建或远程环境中安全使用证书。 获取并配置 Apple ID 的信息在完成证书相关操作后，接下来需要准备 Apple ID 及相关信息，以便后续自动化签名和公证流程使用。 1. 获取 App 专用密码 访问 Apple 账户管理页面 并登录你的 Apple ID。 在“登录和安全”部分，找到“App 专用密码”。 点击“生成 App 专用密码”，并按照页面提示完成操作，保存生成的专用密码。 2. 配置环境变量 将你的 Apple ID 邮箱设置为 APPLE_ID 环境变量。 将上一步生成的 App 专用密码设置为 APPLE_PASSWORD 环境变量。 3. 获取 Apple Team ID 登录 Apple Developer 账户。 在“Membership”或“团队”信息页面，可以看到你的 Team ID。 将 Team ID 设置为 APPLE_TEAM_ID 环境变量。 小贴士：这些环境变量在后续自动化打包、签名、公证等流程中会被频繁用到，建议妥善保存，并避免泄露。 获取并配置 App Store Connect 信息在完成 Apple ID 相关配置后，还需要准备 App Store Connect 的集成密钥信息，以便后续自动化上传、公证等操作。 1. 生成 App Store Connect API 密钥 打开 App Store Connect 用户和访问页面 ，切换到“集成”选项卡。 点击右上角“+”按钮，添加新的密钥信息。 名字可以自定义，访问权限请选择“开发者”。 点击“生成”按钮，完成密钥创建。 2. 配置环境变量 在“集成”页面可以看到“Issuer ID”信息，复制并设置为 APPLE_API_ISSUER 环境变量。 在有效的密钥列表中，有一列“密钥ID”，复制对应的密钥 ID 信息，并设置为 APPLE_API_KEY 环境变量。 下载密钥文件（.p8），注意：密钥只能下载一次，且页面刷新后才可见下载按钮。下载后请妥善保存。 打开下载的密钥文件，将内容设置为 APPLE_API_KEY_CONTENT 环境变量。 将密钥文件路径（如 /your path/AuthKey_xxx.p8，其中xxx为你的密钥ID）设置为 APPLE_API_KEY_PATH 环境变量。 注意：这些密钥和ID信息非常重要，建议妥善保存并避免泄露。密钥文件只能下载一次，丢失后需重新生成。 打包与环境变量检查Tauri 应用打包流程本身较为简单，核心在于前面环境变量的正确配置。打包前请务必确认所有 Apple 相关环境变量已生效。 你可以在终端执行以下命令，检查环境变量： env | grep APPLE 确保输出中包含了你设置的所有证书、公证等相关变量。 常见问题 如遇签名或公证失败，优先检查证书、环境变量（可用 env | grep APPLE 检查）、Apple ID 及密钥信息是否正确，并确保钥匙串中 Apple 根证书与中间证书完整（可前往 Apple 官方证书页面 下载缺失证书）。 staple and validate action failed! Error 65 解决办法该错误多因 Apple G3 根证书缺失或信任设置不当导致。请按如下步骤排查： 访问 AppleRootCA-G3.cer 下载并安装 Apple G3 根证书。 安装后，打开“钥匙串访问”，在“系统”钥匙串中找到“Apple Root CA - G3”证书。 右键点击证书，选择“显示简介”，在“信任”选项中，将“使用此证书时”设置为“使用系统默认”（切勿选择“始终信任”）。 关闭窗口保存设置，重启“钥匙串访问”或电脑。 重新执行 Tauri 的公证流程。 特别提醒：“始终信任”会导致 Apple 公证服务无法正确识别证书链，务必选择“使用系统默认”。 如仍有问题，建议检查证书链完整性，并参考 Tauri 官方文档或社区讨论。","categories":[{"name":"前端","slug":"前端","permalink":"https://74hz.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Tauri","slug":"Tauri","permalink":"https://74hz.github.io/tags/Tauri/"},{"name":"macOS","slug":"macOS","permalink":"https://74hz.github.io/tags/macOS/"},{"name":"代码签名","slug":"代码签名","permalink":"https://74hz.github.io/tags/%E4%BB%A3%E7%A0%81%E7%AD%BE%E5%90%8D/"},{"name":"软件公证","slug":"软件公证","permalink":"https://74hz.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%85%AC%E8%AF%81/"}]},{"title":"博客序言","slug":"博客序言","date":"2025-07-23T03:22:32.000Z","updated":"2025-07-23T06:33:43.664Z","comments":true,"path":"article/c9a6c86b3515/","link":"","permalink":"https://74hz.github.io/article/c9a6c86b3515/","excerpt":"","text":"这是我博客的第一篇文章，我想借此机会简单说明这个平台存在的意义，以及未来希望与你共同探索的方向。 初衷这里会存放我学习技术、阅读书籍或实践项目时的思考与总结。无论是代码片段、工具使用心得，还是对某个领域的阶段性理解，都希望通过文字沉淀下来，既是自我复盘，也希望能为偶然路过的你提供一丝灵感。 内容目前的计划包括但不限于 技术实践：如个人开发难点记录、学习新鲜技术的开发心得。 读书笔记：技术书籍或文学经典著作的摘录与思考。 生活随笔：偶尔也会跳出代码，聊聊旅行、摄影或其他兴趣领域的尝试。 这个博客更像是一个“数字笔记本”，不求面面俱到，但求真诚与实用。如果其中的某段文字能为你节省时间、启发思路，或仅仅是让你觉得“原来有人和我遇到过同样的问题”，那便是它最大的价值。 如果你对某篇文章有疑问、补充或不同见解，欢迎留下评论。由于系统依赖GitHub仓库，初次评论可能需要简单的初始化操作，感谢你的理解。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://74hz.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://74hz.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"随笔","slug":"随笔","permalink":"https://74hz.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"SourceMap","slug":"SourceMap","permalink":"https://74hz.github.io/tags/SourceMap/"},{"name":"前端工程化","slug":"前端工程化","permalink":"https://74hz.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"调试","slug":"调试","permalink":"https://74hz.github.io/tags/%E8%B0%83%E8%AF%95/"},{"name":"Tauri","slug":"Tauri","permalink":"https://74hz.github.io/tags/Tauri/"},{"name":"macOS","slug":"macOS","permalink":"https://74hz.github.io/tags/macOS/"},{"name":"代码签名","slug":"代码签名","permalink":"https://74hz.github.io/tags/%E4%BB%A3%E7%A0%81%E7%AD%BE%E5%90%8D/"},{"name":"软件公证","slug":"软件公证","permalink":"https://74hz.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%85%AC%E8%AF%81/"}]}